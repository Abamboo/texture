# 面试总结

##面试1

问题：c++如何避免一个文件被



问题1：c++和c#区别

c#和c++不支持多重继承

c#不支持指针

c#中所有的对象都只能通过new来创建，c++的类名_对象名在c#中变为声明一个引用

c#里，数组是存放在托管堆里的

c++允许抛出任何异常，而c#中规定抛出类型为一个派生于system.exception的对象。

问题2：引用和指针使用场景

指针一般指的是某块内存的地址，而引用是一个变量的别名

指针本身就是一个对象，在初始化时指向一个对象，在其它时刻可以指向另一个对象，指针指向一块内存，它的内容是所指内存的地址；引用时某块内存的别名

引用：函数的参数和返回值，重载操作符

指针：存在不指向任何对象的情况；需要在不同时刻指向不同对象

当不需要重新指向时，引用一般优先于指针被选用

问题3：深拷贝和浅拷贝

浅拷贝：位拷贝，拷贝构造函数，赋值重载，

深拷贝：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符

浅拷贝相当于起了一个别名，深拷贝另开一块内存完全复制

待完善

问题4：进程间的通信方式

管道、共享内存、信号量、FIFO、消息队列

问题5：c++多态

不同继承关系的类对象，去调用同一函数，产生了不同的行为

构成多态的条件：调用函数的对象必须是指针或引用；被调用的函数必须是虚函数，且完成了虚函数的重写。

实现：virtual虚函数，子类继承重写

纯虚函数：virtual void function()=0;

派生类继承后只有重写纯虚函数才能实例化对象

```
class Car {
public:
	virtual void fun() = 0;
};
class Bus :public Car {
public:
	virtual void fun() {
		cout << "公交车" << endl;
	}
};
class Train :public Car {
public:
	virtual void fun() {
		cout << "火车" <<endl;
	}
};
void test() {
	Car* c = new Bus;
	c->fun();

	Car* c2 = new Train;
	c2->fun();
}
```

多态的原理：虚函数表。



问题6：头文件

<>标准库函数

""非标准库的文件，自定义头文件

问题7：堆和栈，内存分配

栈：系统自动分配的，自动清除

堆：程序员使用new分配的内存块，由程序员释放

