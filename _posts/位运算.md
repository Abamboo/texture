# 位运算

![1](F:\Git\texture\_posts\image\0926\1.png)

## 位运算

| 运算符 |   作用   |                  示例                  |
| :----: | :------: | :------------------------------------: |
|   &    |  按位与  |        两个操作数同时为1结果为1        |
|   \|   |  按位或  |   两个操作数只要有一个为1，结果就为1   |
|   ~    |  按位非  | 操作数为1，结果为0；操作数为0，结果为1 |
|   ^    | 按位异或 | 两个操作数相同，结果为0；不相同结果为1 |
|   <<   |   左移   |              右侧空位补0               |
|   >>   |   右移   |            左侧空位补符号位            |

**示例**

& 按位与：两个操作数的二进制进行与运算，如果对应的二进制位都是1，则该位的结果值为1，否则为0。&常用于判断数字的奇偶性，例：

3 &1

![2](F:\Git\texture\_posts\image\0926\2.png)

```
int main()
{
	int num;
	cin >> num;
	if (num & 1) cout << "奇数" << endl;
    else cout << "偶数\n";
	return 0;
}
```



## 判断字符是否唯一

思路

1、利用哈希表去重(c++,unordered_set)，题目中要求不使用额外的数据结构

2、位运算：由1可想到用一个长度为26的bool型数组来记录每个字母是否出现过，由此可用一组0-1串来代替bool数组，记录所有字符出现的次数，如果一个字符第一次出现，则将该位置为1，若再次出现，且改为已经为1，则返回false。

将26个字符转换为0-25的数字，分别对应0-25位，该0-1串初始为0，当字符串出现时，修改对应位置：

```
(int)(c-'a')//获取所对应的位置
1<<(int)(c-'a');//左移
bit |= (1<<(int)(c-'a'));//修改对应位置为1
```

代码

```
bool isUnique(string astr) {
        int bit=0;
        for(char c: astr){
            if((bit &(1<<(int)(c-'a'))) !=0) return false;
            bit |= (1<<(int)(c-'a'));
        }
        return true;
    }
```

复杂度分析：时间按复杂的O(n),空间复杂度O(1)